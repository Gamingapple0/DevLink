easy = {
    0: {
        'name': 'Valid Parentheses',
        'problem': """Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.""",
        'examples': """Example 1:
Input: s = "()"
Output: true
Example 2:
Input: s = "()[]{}"
Output: true
Example 3:
Input: s = "(]"
Output: false""",
        'constraints': """1 <= s.length <= 104
s consists of parentheses only '()[]{}'."""
    },
    1: {
        'name': 'Palindrome Number',
        'problem': """Given an integer x, return true if x is a palindrome, and false otherwise.""",
        'examples': """Example 1:
Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.
Example 2:
Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3:
Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.""",
        'constraints': """-231 <= x <= 231 - 1"""
    },
    2: {
        'name': 'Two Sum',
        'problem': """Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.""",
        'examples': """Example 1:
Input: nums = [2, 7, 11, 15], target = 9
Output: [0, 1]
Explanation: nums[0] + nums[1] == 9, so the output is [0, 1].
Example 2:
Input: nums = [3, 2, 4], target = 6
Output: [1, 2]
Example 3:
Input: nums = [3, 3], target = 6
Output: [0, 1]""",
        'constraints': """2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
Only one valid answer exists."""
    },
    3: {
        'name': 'Reverse Integer',
        'problem': """Given a 32-bit signed integer, reverse digits of an integer.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [-231, 231 - 1].""",
        'examples': """Example 1:
Input: x = 123
Output: 321
Example 2:
Input: x = -123
Output: -321
Example 3:
Input: x = 120
Output: 21""",
        'constraints': """-231 <= x <= 231 - 1"""
    },
    4: {
        'name': 'Roman to Integer',
        'problem': """Given a Roman numeral, convert it to an integer.
Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M.""",
        'examples': """Example 1:
Input: s = "III"
Output: 3
Example 2:
Input: s = "IV"
Output: 4
Example 3:
Input: s = "IX"
Output: 9""",
        'constraints': """1 <= s.length <= 15
s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M')."""
    },
    5: {
        'name': 'FizzBuzz',
        'problem': """Write a program that outputs the string representation of numbers from 1 to n.
But for multiples of three, it should output 'Fizz' instead of the number, and for the multiples of five, it should output 'Buzz'. For numbers that are multiples of both three and five, output 'FizzBuzz'.""",
        'examples': """Example 1:
Input: n = 3
Output: ["1", "2", "Fizz"]
Example 2:
Input: n = 5
Output: ["1", "2", "Fizz", "4", "Buzz"]""",
        'constraints': """1 <= n <= 105"""
    },
    6: {
        'name': 'Single Number',
        'problem': """Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?""",
        'examples': """Example 1:
Input: nums = [2, 2, 1]
Output: 1
Example 2:
Input: nums = [4, 1, 2, 1, 2]
Output: 4
Example 3:
Input: nums = [1]
Output: 1""",
        'constraints': """1 <= nums.length <= 3 * 104
-3 * 104 <= nums[i] <= 3 * 104
Each element in the array appears twice except for one element which appears only once."""
    },
    7: {
        'name': 'Majority Element',
        'problem': """Given an array nums of size n, return the majority element.
The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.""",
        'examples': """Example 1:
Input: nums = [3, 2, 3]
Output: 3
Example 2:
Input: nums = [2, 2, 1, 1, 1, 2, 2]
Output: 2""",
        'constraints': """1 <= n <= 5 * 104
-109 <= nums[i] <= 109"""
    },
    8: {
        'name': 'Remove Duplicates from Sorted Array',
        'problem': """Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.""",
        'examples': """Example 1:
Input: nums = [1, 1, 2]
Output: 2
Explanation: Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.
Example 2:
Input: nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]
Output: 5
Explanation: Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.""",
        'constraints': """0 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums is sorted in ascending order."""
    },
    9: {
        'name': 'Merge Two Sorted Lists',
        'problem': """Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.""",
        'examples': """Example 1:
Input: l1 = 1 -> 2 -> 4, l2 = 1 -> 3 -> 4
Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4
Example 2:
Input: l1 = [], l2 = []
Output: []
Example 3:
Input: l1 = [], l2 = 0 -> 3
Output: 0 -> 3""",
        'constraints': """The number of nodes in both lists is in the range [0, 50].
-100 <= Node.val <= 100
Both lists are sorted in non-decreasing order."""
    }
}

medium = {
    0: {
        'name': 'Add Two Numbers',
        'problem': """You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.""",
        'examples': """Example 1:
Input: l1 = 2 -> 4 -> 3, l2 = 5 -> 6 -> 4
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
Example 2:
Input: l1 = 0, l2 = 0
Output: 0
Example 3:
Input: l1 = 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9, l2 = 9 -> 9 -> 9 -> 9
Output: 8 -> 9 -> 9 -> 9 -> 0 -> 0 -> 0 -> 1""",
        'constraints': """The number of nodes in each linked list is in the range [1, 100].
0 <= Node.val <= 9
It is guaranteed that the list represents a number that does not have leading zeros except for the zero itself."""
    },
    1: {
        'name': 'Longest Substring Without Repeating Characters',
        'problem': """Given a string s, find the length of the longest substring without repeating characters.""",
        'examples': """Example 1:
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
Example 2:
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
Example 3:
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3. Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.""",
        'constraints': """0 <= s.length <= 5 * 104
s consists of English letters, digits, symbols, and spaces."""
    },
    2: {
        'name': 'Container With Most Water',
        'problem': """Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai), n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.
Notice that you may not slant the container.""",
        'examples': """Example 1:
Input: height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
Output: 49
Explanation: The above vertical lines are represented by array [1, 8, 6, 2, 5, 4, 8, 3, 7]. In this case, the max area of water (blue section) the container can contain is 49.
Example 2:
Input: height = [1, 1]
Output: 1
Example 3:
Input: height = [4, 3, 2, 1, 4]
Output: 16""",
        'constraints': """2 <= height.length <= 3 * 104
0 <= height[i] <= 3 * 104"""
    },
    3: {
        'name': '3Sum',
        'problem': """Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.""",
        'examples': """Example 1:
Input: nums = [-1, 0, 1, 2, -1, -4]
Output: [[-1, -1, 2], [-1, 0, 1]]
Example 2:
Input: nums = []
Output: []
Example 3:
Input: nums = [0]
Output: []""",
        'constraints': """0 <= nums.length <= 3000
-105 <= nums[i] <= 105"""
    },
    4: {
        'name': 'Valid Sudoku',
        'problem': """Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:
A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.""",
        'examples': """Example 1:
Input: board = [
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
Output: true
Example 2:
Input: board = [
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.""",
        'constraints': """board.length == 9
board[i].length == 9
board[i][j] is a digit or '.'."""
    },
    5: {
        'name': 'Word Search',
        'problem': """Given an m x n grid of characters board and a string word, return true if word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where "adjacent" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.""",
        'examples': """Example 1:
Input: board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
], word = "ABCCED"
Output: true
Example 2:
Input: board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
], word = "SEE"
Output: true
Example 3:
Input: board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
], word = "ABCB"
Output: false""",
        'constraints': """m == board.length
n == board[i].length
1 <= m, n <= 6
1 <= word.length <= 15
board and word consists of only lowercase and uppercase English letters."""
    },
    6: {
        'name': 'Combination Sum',
        'problem': """Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.
The same number may be chosen from candidates an unlimited number of times. Two combinations are distinct if the frequency of at least one of the chosen numbers is different.""",
        'examples': """Example 1:
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation: The combinations are [2,2,3] and [7].
Example 2:
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]""",
        'constraints': """1 <= candidates.length <= 30
1 <= candidates[i] <= 200
All elements of candidates are distinct.
1 <= target <= 500"""
    },
    7: {
        'name': 'Merge Intervals',
        'problem': """Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals in ascending order.""",
        'examples': """Example 1:
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, they are merged into [1,6].
Example 2:
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.""",
        'constraints': """1 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 104"""
    },
    8: {
        'name': 'Reverse Words in a String',
        'problem': """Given an input string s, reverse the order of the words.
A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.
Return a string of the words in reverse order concatenated by a single space.
Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces in the answer.""",
        'examples': """Example 1:
Input: s = "the sky is blue"
Output: "blue is sky the"
Example 2:
Input: s = "  hello world  "
Output: "world hello"
Explanation: Your reversed string should not contain leading or trailing spaces.
Example 3:
Input: s = "a good   example"
Output: "example good a""",
        'constraints': """1 <= s.length <= 104
s contains English letters (upper-case and lower-case), digits, and spaces ' '.
There is at least one word in s."""
    },
    9: {
        'name': 'Longest Increasing Subsequence',
        'problem': """Given an integer array nums, return the length of the longest strictly increasing subsequence.
A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,6,2,7].""",
        'examples': """Example 1:
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
Example 2:
Input: nums = [0,1,0,3,2,3]
Output: 4
Example 3:
Input: nums = [7,7,7,7,7,7,7]
Output: 1""",
        'constraints': """1 <= nums.length <= 2500
-104 <= nums[i] <= 104"""
    }
}

hard = {
    0: {
        'name': 'Regular Expression Matching',
        'problem': """Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*'.
'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).
""",
        'examples': """Example 1:
Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:
Input: s = "mississippi", p = "mis*is*p*."
Output: false
Explanation: "mis*is*p*." does not match the entire string "mississippi".
Example 3:
Input: s = "ab", p = ".*"
Output: true
Explanation: ".*" matches any sequence of characters.""",
        'constraints': """1 <= s.length <= 20
1 <= p.length <= 30
s contains only lowercase English letters.
p contains only lowercase English letters, '.', and '*'."""
    },
    1: {
        'name': 'Trapping Rain Water',
        'problem': """Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
""",
        'examples': """Example 1:
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rainwater (blue section) are being trapped.
Example 2:
Input: height = [4,2,0,3,2,5]
Output: 9
""",
        'constraints': """n == height.length
0 <= n <= 3 * 104
0 <= height[i] <= 105"""
    },
    2: {
        'name': 'Median of Two Sorted Arrays',
        'problem': """Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
The overall run time complexity should be O(log (m+n)).
""",
        'examples': """Example 1:
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: The median is 2.
Example 2:
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: The median is (2 + 3)/2 = 2.5.
Example 3:
Input: nums1 = [0,0], nums2 = [0,0]
Output: 0.00000
Explanation: The median is 0.""",
        'constraints': """nums1.length == m
nums2.length == n
0 <= m, n <= 1000
1 <= m + n <= 2000
-106 <= nums1[i], nums2[i] <= 106"""
    },
    3: {
        'name': 'Distinct Subsequences',
        'problem': """Given two strings s and t, return the number of distinct subsequences of s which equals t.
A string's subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ACE" is a subsequence of "ABCDE" while "AEC" is not).""",
        'examples': """Example 1:
Input: s = "rabbbit", t = "rabbit"
Output: 3
Explanation: There are 3 ways to generate "rabbit" from "rabbbit":
- "ra_bb_it" (remove 1st, 3rd, and 6th 'b')
- "rab_bb_it" (remove 1st, 2nd, and 6th 'b')
- "rabb_bit" (remove 1st, 2nd, and 5th 'b')
Example 2:
Input: s = "babgbag", t = "bag"
Output: 5
Explanation: There are 5 ways to generate "bag" from "babgbag":
- "ba_bg_bag" (remove 2nd, 4th, and 6th 'b')
- "ba_b_gb_ag" (remove 2nd, 4th, and 5th 'b')
- "ba_b_g_bag" (remove 2nd, 4th, and 3rd 'b')
- "ba_bgba_g" (remove 2nd, 4th, and 1st 'b')
- "babg_bag" (remove 4th and 6th 'b')""",
        'constraints': """0 <= s.length, t.length <= 1000
s and t consist of English letters."""
    },
    4: {
        'name': 'Wildcard Matching',
        'problem': """Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.
'?' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).
""",
        'examples': """Example 1:
Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:
Input: s = "aa", p = "*"
Output: true
Explanation: '*' matches any sequence.
Example 3:
Input: s = "cb", p = "?a"
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.""",
        'constraints': """0 <= s.length, p.length <= 2000
s contains only lowercase English letters.
p contains only lowercase English letters, '?' or '*'."""
    },
    5: {
        'name': 'Substring with Concatenation of All Words',
        'problem': """You are given a string s and an array of words words, where you need to find all the starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.

Return a list of the starting indices of the substring(s) in s that satisfies the requirements.
""",
        'examples': """Example 1:
Input: s = "barfoothefoobarman", words = ["foo","bar"]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are "barfoo" and "foobar" respectively, which are concatenations of all words in the list.
Example 2:
Input: s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
Output: []""",
        'constraints': """1 <= s.length <= 104
s consists of lower-case English letters.
1 <= words.length <= 5000
1 <= words[i].length <= 100
All the words in words are unique."""
    },
    6: {
        'name': 'Minimum Window Substring',
        'problem': """Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string "".

The testcases will be generated such that the answer is unique.

A substring is a contiguous sequence of characters within the string.
""",
        'examples': """Example 1:
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
Example 2:
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window substring.
Example 3:
Input: s = "a", t = "aa"
Output: ""
Explanation: There is no substring that includes 'aa' from string t in s.""",
        'constraints': """1 <= m, n <= 105
s and t consist of English letters."""
    },
    7: {
        'name': 'First Missing Positive',
        'problem': """Given an unsorted integer array nums, find the smallest missing positive integer.

Follow up: Could you implement an algorithm that runs in O(n) time and uses constant extra space?
""",
        'examples': """Example 1:
Input: nums = [1,2,0]
Output: 3
Example 2:
Input: nums = [3,4,-1,1]
Output: 2
Example 3:
Input: nums = [7,8,9,11,12]
Output: 1""",
        'constraints': """0 <= nums.length <= 300
-231 <= nums[i] <= 231 - 1"""
    },
    8: {
        'name': 'Longest Valid Parentheses',
        'problem': """Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.
""",
        'examples': """Example 1:
Input: s = "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()".
Example 2:
Input: s = ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()".
Example 3:
Input: s = ""
Output: 0""",
        'constraints': """0 <= s.length <= 3 * 104
s[i] is '(', or ')'. """
    },
    9: {
        'name': 'Sudoku Solver',
        'problem': """Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy all of the following rules:
Each of the digits 1-9 must occur exactly once in each row.
Each of the digits 1-9 must occur exactly once in each column.
Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.
The '.' character indicates empty cells.
""",
        'examples': """Example 1:
Input: board = [
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
Output: [
  ["5","3","4","6","7","8","9","1","2"],
  ["6","7","2","1","9","5","3","4","8"],
  ["1","9","8","3","4","2","5","6","7"],
  ["8","5","9","7","6","1","4","2","3"],
  ["4","2","6","8","5","3","7","9","1"],
  ["7","1","3","9","2","4","8","5","6"],
  ["9","6","1","5","3","7","2","8","4"],
  ["2","8","7","4","1","9","6","3","5"],
  ["3","4","5","2","8","6","1","7","9"]
]
Explanation: The input board is a Sudoku puzzle. The output is its solved form.
Example 2:
Input: board = [
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
Output: [
  ["8","3","4","6","7","2","9","1","5"],
  ["6","7","5","1","9","8","3","4","2"],
  ["1","9","8","3","4","7","5","6","2"],
  ["8","5","9","7","6","4","2","3","1"],
  ["4","2","6","8","5","3","7","9","1"],
  ["7","1","3","9","2","4","8","5","6"],
  ["9","6","7","5","3","1","2","8","4"],
  ["2","8","1","4","1","9","6","7","5"],
  ["3","4","5","2","8","6","1","7","9"]
]
Explanation: The input board is a Sudoku puzzle. The output is its solved form.""",
        'constraints': """board.length == 9
board[i].length == 9
board[i][j] is a digit or '.'."""
    }
}